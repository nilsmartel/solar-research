-- best with haskell syntax highlighting

fullidentifer
   -- TODO path
   - path?
   - identifer

identifer
   -- NOTE: not <keyword>
   - ([a-z][A-Z])+([a-z][A-Z][0-9])*(_([a-z][A-Z][0-9])*)*

fullexpression
    - fe0 (":", fe0)*
    - fe1 (".", fe1)* -- see: discussion/dot-openrator.sol
fe1
    - fe2 ("and" fe2)*
    {-- ...
        "or"
        ++
        +
        -
        *
        /
        a^a
        âˆša
        -a
        !a
        <expression>
    --}

expression
    / functioncall
    / value

literal
    / bool
    / int
    / float
    / string

value
    / literal
    / fullidentifier
    / closure
    / array
    / "|" fullexpression "|"
    -- tuple or parenthesis
    / "(" fullexpression ** "," ")"
    / match
    / blockexpression
    -- Might be included. Complicates things. Hard to read for beginners
    -- / "$" fullexpression

arrayguard
    - "["
    - (matchguard ** ",")
    - "]"
    - ("++ " identifer)?

objectguard
    - fullidentifier
    - ((identifier "=")? literal)*

tupleguard
    - "("
    - matchguard ** ","
    - ")"

matchguard
    / literal
    / objectguard
    / arrayguard
    / tupleguard
    / identifer

match
    - "match" fullexpression
    - "is" matchguard "then" fullexpression
    - ("else" fullexpression)?

closure
    - "("
    - functionarguments ** ","
    - ")"
    - "=>"
    - fullexpression

blockexpression
    - "{"
    -- there may be as many ; as you need. They are only needed to separate expression
    - (be-part / ";")*
    - "}"

be-part
    / "let" identifer "=" fullexpression
    / "return" fullexpression?
    / fullexpression
    / "loop" blockexpression
    / "if" fullexpression "do" blockexpression
    / "for" identifer "in" fullexpression "do" blockexpression


-- sin 3.14
-- call "Sally" "+1489732567890" (Message from="david" text="Hello world")
-- call person="Sally" number="+012345678" message=(Message from"david" text="Hello world")
functioncall
    - identifier
    - functioncallarg*

functioncallarg
    - (identifier "=")?
    - value

